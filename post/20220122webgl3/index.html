<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>《WebGL编程指南》阅读笔记 - al4fun&#39;s notes</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="al4fun" /><meta name="description" content="1 WebGL概述 OpenGL &amp;amp; OpenGL ES &amp;amp; WebGL的版本对应关系 2 WebGL入门 零散 片段（fragment，也称为片元）是一个WebGL术语，你可以将其理" /><meta name="keywords" content="android, web, flutter" />






<meta name="generator" content="Hugo 0.92.0 with theme even" />


<link rel="canonical" href="https://al4fun.gitee.io/post/20220122webgl3/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.cb68f97bc9cece255d217346d970e3c62623408634e500c330a62fadabbbe77c.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="《WebGL编程指南》阅读笔记" />
<meta property="og:description" content="1 WebGL概述 OpenGL &amp; OpenGL ES &amp; WebGL的版本对应关系 2 WebGL入门 零散 片段（fragment，也称为片元）是一个WebGL术语，你可以将其理" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://al4fun.gitee.io/post/20220122webgl3/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-22T21:05:11+00:00" />
<meta property="article:modified_time" content="2022-01-22T21:05:11+00:00" />

<meta itemprop="name" content="《WebGL编程指南》阅读笔记">
<meta itemprop="description" content="1 WebGL概述 OpenGL &amp; OpenGL ES &amp; WebGL的版本对应关系 2 WebGL入门 零散 片段（fragment，也称为片元）是一个WebGL术语，你可以将其理"><meta itemprop="datePublished" content="2022-01-22T21:05:11+00:00" />
<meta itemprop="dateModified" content="2022-01-22T21:05:11+00:00" />
<meta itemprop="wordCount" content="9585">
<meta itemprop="keywords" content="WebGL," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="《WebGL编程指南》阅读笔记"/>
<meta name="twitter:description" content="1 WebGL概述 OpenGL &amp; OpenGL ES &amp; WebGL的版本对应关系 2 WebGL入门 零散 片段（fragment，也称为片元）是一个WebGL术语，你可以将其理"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">al4fun&#39;s notes</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">al4fun&#39;s notes</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">《WebGL编程指南》阅读笔记</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-22 </span>
        <div class="post-category">
            <a href="/categories/3d%E5%9B%BE%E5%BD%A2%E6%8A%80%E6%9C%AF/"> 3D图形技术 </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-webgl概述">1 WebGL概述</a></li>
    <li><a href="#2-webgl入门">2 WebGL入门</a>
      <ul>
        <li><a href="#零散">零散</a></li>
        <li><a href="#向attribute变量传值原理">向attribute变量传值原理</a></li>
        <li><a href="#获取鼠标点击位置在webgl中对应的点的坐标">获取鼠标点击位置在WebGL中对应的点的坐标</a></li>
      </ul>
    </li>
    <li><a href="#3-绘制和变换三角形">3 绘制和变换三角形</a>
      <ul>
        <li><a href="#零散-1">零散</a></li>
        <li><a href="#使用缓冲区对象向顶点着色器传入顶点数据">使用缓冲区对象向顶点着色器传入顶点数据</a></li>
        <li><a href="#图元类型">图元类型</a></li>
      </ul>
    </li>
    <li><a href="#4-高级变换与动画基础">4 高级变换与动画基础</a>
      <ul>
        <li><a href="#矩阵乘法">矩阵乘法</a></li>
      </ul>
    </li>
    <li><a href="#5-颜色和纹理">5 颜色和纹理</a>
      <ul>
        <li><a href="#纹理单元">纹理单元</a></li>
        <li><a href="#使用缓冲区对象向顶点着色器传入多种顶点数据">使用缓冲区对象向顶点着色器传入多种顶点数据</a>
          <ul>
            <li><a href="#1使用多个缓冲区对象">(1)使用多个缓冲区对象</a></li>
            <li><a href="#2使用单个缓冲区对象">(2)使用单个缓冲区对象</a></li>
          </ul>
        </li>
        <li><a href="#使用多幅纹理">使用多幅纹理</a></li>
      </ul>
    </li>
    <li><a href="#6-glsl-es">6 GLSL ES</a></li>
    <li><a href="#7-进入三维世界">7 进入三维世界</a>
      <ul>
        <li><a href="#可视空间">可视空间</a></li>
        <li><a href="#正确处理对象的前后关系">正确处理对象的前后关系</a>
          <ul>
            <li><a href="#隐藏面消除">隐藏面消除</a></li>
            <li><a href="#深度冲突了解">深度冲突(了解)</a></li>
          </ul>
        </li>
        <li><a href="#通过顶点索引绘制物体">通过顶点索引绘制物体</a></li>
      </ul>
    </li>
    <li><a href="#8-光照">8 光照</a>
      <ul>
        <li><a href="#光源类型">光源类型</a></li>
        <li><a href="#反射类型">反射类型</a></li>
        <li><a href="#平行光下的漫反射计算原理">平行光下的漫反射计算原理</a></li>
        <li><a href="#环境反射计算原理">环境反射计算原理</a></li>
        <li><a href="#魔法矩阵逆转置矩阵">魔法矩阵：逆转置矩阵</a></li>
        <li><a href="#点光源下的漫反射计算原理">点光源下的漫反射计算原理</a></li>
        <li><a href="#更逼真的效果逐片元光照了解">更逼真的效果：逐片元光照(了解)</a></li>
      </ul>
    </li>
    <li><a href="#9-层次模型">9 层次模型</a>
      <ul>
        <li><a href="#层次结构模型">层次结构模型</a></li>
        <li><a href="#单关节模型">单关节模型</a></li>
      </ul>
    </li>
    <li><a href="#10-高级技术">10 高级技术</a>
      <ul>
        <li><a href="#选中物体">选中物体</a></li>
        <li><a href="#hud">HUD</a></li>
        <li><a href="#绘制圆形的点">绘制圆形的点</a></li>
        <li><a href="#α混合">α混合</a>
          <ul>
            <li><a href="#如何实现α混合">如何实现α混合</a></li>
            <li><a href="#混合函数">混合函数</a></li>
            <li><a href="#半透明的三维物体">半透明的三维物体</a></li>
            <li><a href="#透明与不透明物体共存">透明与不透明物体共存</a></li>
          </ul>
        </li>
        <li><a href="#切换着色器">切换着色器</a></li>
        <li><a href="#使用渲染结果作为纹理使用帧缓冲区对象">使用渲染结果作为纹理——使用帧缓冲区对象</a></li>
        <li><a href="#绘制阴影">绘制阴影</a></li>
        <li><a href="#加载obj格式的三维模型">加载OBJ格式的三维模型</a></li>
        <li><a href="#处理上下文丢失">处理上下文丢失</a></li>
      </ul>
    </li>
    <li><a href="#11-附录">11 附录</a>
      <ul>
        <li><a href="#左手坐标系or右手坐标系">左手坐标系or右手坐标系</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="1-webgl概述">1 WebGL概述</h1>
<p><strong>OpenGL &amp; OpenGL ES &amp; WebGL的版本对应关系</strong></p>
<p><img src="1.PNG" alt=""></p>
<h1 id="2-webgl入门">2 WebGL入门</h1>
<h2 id="零散">零散</h2>
<p><strong>片段</strong>（fragment，也称为片元）是一个WebGL术语，你可以将其理解为像素。</p>
<p>顶点着色器中的<strong>gl_position</strong>是一个齐次坐标，对于笛卡尔坐标系下的点(x,y,z)，它的齐次坐标就是(x,y,z,1.0)。</p>
<p>顶点着色器进行的是逐顶点的操作，片段着色器进行的是逐片段的操作。</p>
<h2 id="向attribute变量传值原理">向attribute变量传值原理</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="c1">// 顶点着色器代码</span>
<span class="k">attribute</span> <span class="k">vec4</span> <span class="n">a_Position</span><span class="p">;</span>
<span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">a_Position</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">// js代码
</span><span class="c1">// Get the storage location of a_Position
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">a_Position</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">getAttribLocation</span><span class="p">(</span><span class="nx">program</span><span class="p">,</span> <span class="s1">&#39;a_Position&#39;</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">a_Position</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Failed to get the storage location of a_Position&#39;</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>WebGL会解析着色器程序，辨别出其中的attribute变量。每个attribute变量都有一个存储地址，我们通过<code>getAttribLocation</code>函数来获取这个存储地址，然后就可以通过这个存储地址来向该attribute变量传值。</p>
<blockquote>
<p>向uniform变量传值的原理也类似。</p>
</blockquote>
<h2 id="获取鼠标点击位置在webgl中对应的点的坐标">获取鼠标点击位置在WebGL中对应的点的坐标</h2>
<p>注意两点：</p>
<p>1.鼠标点击位置坐标是在“浏览器客户区”(client area)中的坐标，而不是<code>&lt;cavas&gt;</code>中的。</p>
<p><img src="2.PNG" alt=""></p>
<p>2.<code>&lt;cavas&gt;</code>的坐标系统（下左图）与WebGL的坐标系统（下右图），其原点位置和Y轴的正方向都不一样。</p>
<p><img src="3.PNG" alt=""></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">canvas</span><span class="p">.</span><span class="nx">onmousedown</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">ev</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">click</span><span class="p">(</span><span class="nx">ev</span><span class="p">,</span> <span class="nx">gl</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">,</span> <span class="nx">a_Position</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">g_points</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">function</span> <span class="nx">click</span><span class="p">(</span><span class="nx">ev</span><span class="p">,</span> <span class="nx">gl</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">,</span> <span class="nx">a_Position</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">clientX</span><span class="p">;</span> <span class="c1">// x coordinate of a mouse pointer
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">clientY</span><span class="p">;</span> <span class="c1">// y coordinate of a mouse pointer
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">rect</span> <span class="o">=</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">getBoundingClientRect</span><span class="p">();</span>
  <span class="nx">x</span> <span class="o">=</span> <span class="p">((</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">rect</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">-</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  <span class="nx">y</span> <span class="o">=</span> <span class="p">(</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">rect</span><span class="p">.</span><span class="nx">top</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>

  <span class="c1">// Store the coordinates to g_points array
</span><span class="c1"></span>  <span class="nx">g_points</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="nx">g_points</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>以横坐标的换算<code>x = ((x - rect.left) - canvas.width / 2) / (canvas.width / 2)</code>为例：</p>
<ul>
<li><code>x - rect.left</code>：得到鼠标点击位置在canvas中的坐标。</li>
<li><code>- canvas.width / 2</code>：平移坐标系。</li>
<li><code>/ (canvas.width / 2)</code>：缩放坐标系。</li>
</ul>
<h1 id="3-绘制和变换三角形">3 绘制和变换三角形</h1>
<h2 id="零散-1">零散</h2>
<p>不管三维模型的形状多么复杂，其基本组成单位都是三角形。</p>
<h2 id="使用缓冲区对象向顶点着色器传入顶点数据">使用缓冲区对象向顶点着色器传入顶点数据</h2>
<p>缓冲区对象(buffer object)是WebGL系统中的一块内存区域，我们可以在缓冲区对象中保存大量的顶点数据，供顶点着色器使用。</p>
<blockquote>
<p>以下代码以传递顶点坐标为例。实际上传递顶点颜色、顶点纹理坐标等也是一样的方法。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">initVertexBuffers</span><span class="p">(</span><span class="nx">gl</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 顶点坐标。三组，每组两个，分别为x和y
</span><span class="c1"></span>  <span class="c1">// 使用了WebGL提供的类型化数组，即元素只能是某种类型的数组
</span><span class="c1"></span>  <span class="c1">// WebGL 处理类型化数组 会比 处理元素可能是任意类型的普通数组Array 效率更高
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">vertices</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Float32Array</span><span class="p">([</span>
    <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span>
  <span class="p">]);</span>
  <span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// 顶点数量
</span><span class="c1"></span>
  <span class="c1">// 创建缓冲区对象
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">vertexBuffer</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">vertexBuffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Failed to create the buffer object&#39;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// 将缓冲区对象绑定到目标ARRAY_BUFFER
</span><span class="c1"></span>  <span class="c1">// bindBuffer(target, buffer)
</span><span class="c1"></span>  <span class="c1">// 目标有两种：
</span><span class="c1"></span>  <span class="c1">//   1.ARRAY_BUFFER: 表示缓冲区对象用来存储顶点数据
</span><span class="c1"></span>  <span class="c1">//   2.ELEMENT_ARRAY_BUFFER: 表示缓冲区对象用来存储顶点的索引值
</span><span class="c1"></span>  <span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="nx">vertexBuffer</span><span class="p">);</span>
  <span class="c1">// 向绑定到ARRAY_BUFFER的缓冲区对象写入数据
</span><span class="c1"></span>  <span class="c1">// bufferData(target, data, usage)
</span><span class="c1"></span>  <span class="c1">// usage表示程序将如何使用缓冲区中的数据。该参数将帮助webgl优化操作，但即便你传入了错误的值，程序也能运行，只是效率会略低
</span><span class="c1"></span>  <span class="c1">// gl.STATIC_DRAW: 缓冲区的内容可能经常使用，而不会经常更改。
</span><span class="c1"></span>  <span class="c1">// gl.DYNAMIC_DRAW: 缓冲区的内容可能经常使用，并且经常更改。
</span><span class="c1"></span>  <span class="c1">// gl.STREAM_DRAW: 缓冲区的内容可能不会经常使用。
</span><span class="c1"></span>  <span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="nx">vertices</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">STATIC_DRAW</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">a_Position</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">getAttribLocation</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">program</span><span class="p">,</span> <span class="s1">&#39;a_Position&#39;</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">a_Position</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Failed to get the storage location of a_Position&#39;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// 将与ARRAY_BUFFER绑定的缓冲区对象分配给a_Position
</span><span class="c1"></span>  <span class="c1">// vertexAttribPointer(location, size, type, normalized, stride, offset)
</span><span class="c1"></span>  <span class="c1">//   size: 指定缓冲区中每个顶点的分量个数(1到4)。若size比attribute变量需要的分量数小，缺失分量将被自动补全。
</span><span class="c1"></span>  <span class="c1">//         比如，如果size为1，那么第二三分量会自动设为0，第四分量会自动设为1。
</span><span class="c1"></span>  <span class="c1">//   stride: 相邻两个顶点间的字节数。如果指定为0，则会根据size和type自动计算。
</span><span class="c1"></span>  <span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="nx">a_Position</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="c1">// 使分配生效
</span><span class="c1"></span>  <span class="nx">gl</span><span class="p">.</span><span class="nx">enableVertexAttribArray</span><span class="p">(</span><span class="nx">a_Position</span><span class="p">);</span>

  <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="图元类型">图元类型</h2>
<p><code>gl.drawArrays(mode, first, count)</code>：</p>
<ul>
<li>mode: 要绘制的图元类型。</li>
<li>first: 从哪个顶点开始绘制。</li>
<li>count: 要绘制多少个顶点。</li>
</ul>
<p>图元类型有以下几种：</p>
<ul>
<li>POINTS：绘制点。</li>
<li>LINES：绘制线。将传入的顶点，依次两两配对组成线段进行绘制（即，假设有ABCD四个顶点，则会在AB之间、CD之间分别绘制线段），若顶点数为奇数，则将最后一个给忽略掉。</li>
<li>LINE_STRIP：绘制线。将传入的顶点，进行依次的连接绘制。</li>
<li>LINE_LOOP：绘制线。将传入的顶点，进行依次的连接绘制，最后将首尾顶点进行连接，形成一个闭环。</li>
<li>TRIANGLE：绘制三角形。</li>
<li>TRIANGLE_STRIP：绘制三角形带。前三个点构成了第1个三角形，从第2个点开始的3个点构成了第2个三角形，以此类推。这些三角形分别为(v0,v1,v2)、(v2,v1,v3)、(v2,v3,v4)…注意第2个三角形是(v2,v1,v3)而不是(v1,v2,v3)，这是为了保证它的绘制方向（顺时针或逆时针）和前一个三角形一致。</li>
<li>TRIANGLE_FAN：绘制扇形。以第一个点为中心点，其它顶点作为边缘点绘制出组成扇型的相邻三角形。</li>
</ul>
<p><img src="4.PNG" alt=""></p>
<blockquote>
<p>TRIANGLE_STRIP稍微有点复杂。其规律是构建当前三角形的顶点的连接顺序依赖于要和前面已经出现过的2个顶点组成三角形的当前顶点的序号的奇偶性(如果从0开始)：</p>
<ul>
<li>如果当前顶点是奇数：组成三角形的顶点排列顺序：T = [n-1 n-2 n].</li>
<li>如果当前顶点是偶数：组成三角形的顶点排列顺序：T = [n-2 n-1 n].</li>
</ul>
<p>以上图为例，第一个三角形，顶点v2序号是2，是偶数，则顶点排列顺序是v0,v1,v2。第二个三角形，顶点v3序号是3，是奇数，则顶点排列顺序是v2,v1,v3，第三个三角形，顶点v4序号是4，是偶数，则顶点排列顺序是v2,v3,v4,以此类推。这个顺序是为了保证所有的三角形都是按照相同的方向绘制的，使这个三角形串能够正确形成表面的一部分。对于某些操作，维持方向是很重要的，比如剔除。</p>
<p>TRIANGLE_FAN与TRIANGLE_STRIP类似，不过它的三角形的顶点排列顺序是T = [0 n-1 n]。各三角形形成一个扇形序列。</p>
</blockquote>
<h1 id="4-高级变换与动画基础">4 高级变换与动画基础</h1>
<h2 id="矩阵乘法">矩阵乘法</h2>
<p>矩阵乘法<strong>有结合律</strong>，但<strong>没有交换律</strong>。</p>
<p>顶点坐标<code>vec4</code>本质上也是一个<code>4*1</code>的矩阵，对于<code>(矩阵A*矩阵B)*顶点坐标</code>，根据矩阵乘法的结合律，它等价于<code>矩阵A*(矩阵B*顶点坐标)</code>，也就是说，对顶点坐标先做矩阵B对应的变换，再做矩阵A对应的变换。</p>
<h1 id="5-颜色和纹理">5 颜色和纹理</h1>
<h2 id="纹理单元">纹理单元</h2>
<p>WebGL通过一种称为 <strong>纹理单元(texture unit)</strong> 的机制来同时使用多个纹理。每个纹理单元有一个单元编号，管理一张纹理图像。</p>
<p>系统支持的纹理单元个数取决于硬件和浏览器的WebGL实现，默认情况下，WebGL至少支持8个纹理单元。</p>
<h2 id="使用缓冲区对象向顶点着色器传入多种顶点数据">使用缓冲区对象向顶点着色器传入多种顶点数据</h2>
<p>顶点着色器代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">attribute</span> <span class="k">vec4</span> <span class="n">a_Position</span><span class="p">;</span>
<span class="k">attribute</span> <span class="k">float</span> <span class="n">a_PointSize</span><span class="p">;</span>
<span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">a_Position</span><span class="p">;</span>
  <span class="n">gl_PointSize</span> <span class="o">=</span> <span class="n">a_PointSize</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="1使用多个缓冲区对象">(1)使用多个缓冲区对象</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">initVertexBuffers</span><span class="p">(</span><span class="nx">gl</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 顶点坐标
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">vertices</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Float32Array</span><span class="p">([</span>
    <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span>
  <span class="p">]);</span>
  <span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span><span class="c1">// 顶点数
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">vertexBuffer</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="nx">vertexBuffer</span><span class="p">);</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="nx">vertices</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">STATIC_DRAW</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">a_Position</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">getAttribLocation</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">program</span><span class="p">,</span> <span class="s1">&#39;a_Position&#39;</span><span class="p">);</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="nx">a_Position</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">enableVertexAttribArray</span><span class="p">(</span><span class="nx">a_Position</span><span class="p">);</span>

  <span class="c1">// 顶点的尺寸
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">sizes</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Float32Array</span><span class="p">([</span>
    <span class="mf">10.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">30.0</span>
  <span class="p">]);</span>
  <span class="kd">var</span> <span class="nx">sizeBuffer</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="nx">sizeBuffer</span><span class="p">);</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="nx">sizes</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">STATIC_DRAW</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">a_PointSize</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">getAttribLocation</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">program</span><span class="p">,</span> <span class="s1">&#39;a_PointSize&#39;</span><span class="p">);</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="nx">a_PointSize</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">enableVertexAttribArray</span><span class="p">(</span><span class="nx">a_PointSize</span><span class="p">);</span>

  <span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="2使用单个缓冲区对象">(2)使用单个缓冲区对象</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">initVertexBuffers</span><span class="p">(</span><span class="nx">gl</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 顶点的坐标和尺寸
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">verticesSizes</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Float32Array</span><span class="p">([</span>
    <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span>  <span class="c1">// the 1st point
</span><span class="c1"></span>    <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span>  <span class="c1">// the 2nd point
</span><span class="c1"></span>    <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">30.0</span>   <span class="c1">// the 3rd point
</span><span class="c1"></span>  <span class="p">]);</span>
  <span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// 顶点数
</span><span class="c1"></span>
  <span class="c1">// 缓冲区对象
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">vertexSizeBuffer</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="nx">vertexSizeBuffer</span><span class="p">);</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="nx">verticesSizes</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">STATIC_DRAW</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">FSIZE</span> <span class="o">=</span> <span class="nx">verticesSizes</span><span class="p">.</span><span class="nx">BYTES_PER_ELEMENT</span><span class="p">;</span>

  <span class="c1">// 顶点坐标
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">a_Position</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">getAttribLocation</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">program</span><span class="p">,</span> <span class="s1">&#39;a_Position&#39;</span><span class="p">);</span>
  <span class="c1">// vertexAttribPointer(location, size, type, normalized, stride, offset)
</span><span class="c1"></span>  <span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="nx">a_Position</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">FSIZE</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">enableVertexAttribArray</span><span class="p">(</span><span class="nx">a_Position</span><span class="p">);</span>

  <span class="c1">// 顶点的尺寸
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">a_PointSize</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">getAttribLocation</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">program</span><span class="p">,</span> <span class="s1">&#39;a_PointSize&#39;</span><span class="p">);</span>
  <span class="c1">// vertexAttribPointer(location, size, type, normalized, stride, offset)
</span><span class="c1"></span>  <span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="nx">a_PointSize</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">FSIZE</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">FSIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">enableVertexAttribArray</span><span class="p">(</span><span class="nx">a_PointSize</span><span class="p">);</span>

  <span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="使用多幅纹理">使用多幅纹理</h2>
<p>在本章之前说过，WebGL可以同时处理多幅纹理，纹理单元就是为了这个目的而设计的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">VSHADER_SOURCE</span> <span class="o">=</span> <span class="sb">`
</span><span class="sb">    attribute vec4 a_Position;
</span><span class="sb">    attribute vec2 a_TexCoord;
</span><span class="sb">    varying vec2 v_TexCoord;
</span><span class="sb">    void main() {
</span><span class="sb">        gl_Position = a_Position;
</span><span class="sb">        v_TexCoord = a_TexCoord;
</span><span class="sb">    }
</span><span class="sb">`</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">FSHADER_SOURCE</span> <span class="o">=</span> <span class="sb">`
</span><span class="sb">    #ifdef GL_ES
</span><span class="sb">    precision mediump float;
</span><span class="sb">    #endif
</span><span class="sb">    uniform sampler2D u_Sampler0;
</span><span class="sb">    uniform sampler2D u_Sampler1;
</span><span class="sb">    varying vec2 v_TexCoord;
</span><span class="sb">    void main() {
</span><span class="sb">        vec4 color0 = texture2D(u_Sampler0, v_TexCoord);
</span><span class="sb">        vec4 color1 = texture2D(u_Sampler1, v_TexCoord);
</span><span class="sb">        gl_FragColor = color0 * color1;
</span><span class="sb">    }
</span><span class="sb">`</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;webgl&#39;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">gl</span> <span class="o">=</span> <span class="nx">getWebGLContext</span><span class="p">(</span><span class="nx">canvas</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">gl</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Failed to get the rendering context for WebGL&#39;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">initShaders</span><span class="p">(</span><span class="nx">gl</span><span class="p">,</span> <span class="nx">VSHADER_SOURCE</span><span class="p">,</span> <span class="nx">FSHADER_SOURCE</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Failed to intialize shaders.&#39;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">initVertexBuffers</span><span class="p">(</span><span class="nx">gl</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Failed to set the vertex information&#39;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">gl</span><span class="p">.</span><span class="nx">clearColor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">initTextures</span><span class="p">(</span><span class="nx">gl</span><span class="p">,</span> <span class="nx">n</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Failed to intialize the texture.&#39;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">initVertexBuffers</span><span class="p">(</span><span class="nx">gl</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">verticesTexCoords</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Float32Array</span><span class="p">([</span>
        <span class="c1">// Vertex coordinate, Texture coordinate
</span><span class="c1"></span>        <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="p">]);</span>
    <span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// The number of vertices
</span><span class="c1"></span>
    <span class="kd">var</span> <span class="nx">vertexTexCoordBuffer</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">vertexTexCoordBuffer</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Failed to create the buffer object&#39;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="nx">vertexTexCoordBuffer</span><span class="p">);</span>
    <span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="nx">verticesTexCoords</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">STATIC_DRAW</span><span class="p">);</span>

    <span class="kd">var</span> <span class="nx">FSIZE</span> <span class="o">=</span> <span class="nx">verticesTexCoords</span><span class="p">.</span><span class="nx">BYTES_PER_ELEMENT</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">a_Position</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">getAttribLocation</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">program</span><span class="p">,</span> <span class="s1">&#39;a_Position&#39;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">a_Position</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Failed to get the storage location of a_Position&#39;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="nx">a_Position</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">FSIZE</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="nx">gl</span><span class="p">.</span><span class="nx">enableVertexAttribArray</span><span class="p">(</span><span class="nx">a_Position</span><span class="p">);</span>

    <span class="kd">var</span> <span class="nx">a_TexCoord</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">getAttribLocation</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">program</span><span class="p">,</span> <span class="s1">&#39;a_TexCoord&#39;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">a_TexCoord</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Failed to get the storage location of a_TexCoord&#39;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="nx">a_TexCoord</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">FSIZE</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="nx">FSIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
    <span class="nx">gl</span><span class="p">.</span><span class="nx">enableVertexAttribArray</span><span class="p">(</span><span class="nx">a_TexCoord</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">initTextures</span><span class="p">(</span><span class="nx">gl</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">texture0</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">texture1</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createTexture</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">texture0</span> <span class="o">||</span> <span class="o">!</span><span class="nx">texture1</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Failed to create the texture object&#39;</span><span class="p">);</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">u_Sampler0</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">program</span><span class="p">,</span> <span class="s1">&#39;u_Sampler0&#39;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">u_Sampler1</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">program</span><span class="p">,</span> <span class="s1">&#39;u_Sampler1&#39;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">u_Sampler0</span> <span class="o">||</span> <span class="o">!</span><span class="nx">u_Sampler1</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Failed to get the storage location of u_Sampler&#39;</span><span class="p">);</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">image0</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Image</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">image1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Image</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">image0</span> <span class="o">||</span> <span class="o">!</span><span class="nx">image1</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Failed to create the image object&#39;</span><span class="p">);</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">image0</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="nx">loadTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">texture0</span><span class="p">,</span> <span class="nx">u_Sampler0</span><span class="p">,</span> <span class="nx">image0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="p">};</span>
    <span class="nx">image1</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="nx">loadTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">texture1</span><span class="p">,</span> <span class="nx">u_Sampler1</span><span class="p">,</span> <span class="nx">image1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="p">};</span>
    <span class="nx">image0</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="s1">&#39;../resources/sky.jpg&#39;</span><span class="p">;</span>
    <span class="nx">image1</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="s1">&#39;../resources/circle.gif&#39;</span><span class="p">;</span>

    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Specify whether the texture unit is ready to use
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">g_texUnit0</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">g_texUnit1</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">loadTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">texture</span><span class="p">,</span> <span class="nx">u_Sampler</span><span class="p">,</span> <span class="nx">image</span><span class="p">,</span> <span class="nx">texUnit</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 翻转y轴(因为图片的y轴方向与纹理坐标的y轴方向相反)
</span><span class="c1"></span>    <span class="c1">// Flip the image&#39;s y-axis
</span><span class="c1"></span>    <span class="nx">gl</span><span class="p">.</span><span class="nx">pixelStorei</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">UNPACK_FLIP_Y_WEBGL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="c1">// 激活纹理单元
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">texUnit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">gl</span><span class="p">.</span><span class="nx">activeTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE0</span><span class="p">);</span>
        <span class="nx">g_texUnit0</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">gl</span><span class="p">.</span><span class="nx">activeTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE1</span><span class="p">);</span>
        <span class="nx">g_texUnit1</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">gl</span><span class="p">.</span><span class="nx">bindTexture</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span> <span class="nx">texture</span><span class="p">);</span> <span class="c1">// 绑定
</span><span class="c1"></span>    <span class="nx">gl</span><span class="p">.</span><span class="nx">texParameteri</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">LINEAR</span><span class="p">);</span> <span class="c1">// 设置纹理参数
</span><span class="c1"></span>    <span class="nx">gl</span><span class="p">.</span><span class="nx">texImage2D</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_BYTE</span><span class="p">,</span> <span class="nx">image</span><span class="p">);</span> <span class="c1">// 将image传递给texture
</span><span class="c1"></span>    <span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1i</span><span class="p">(</span><span class="nx">u_Sampler</span><span class="p">,</span> <span class="nx">texUnit</span><span class="p">);</span>

    <span class="nx">gl</span><span class="p">.</span><span class="nx">clear</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_BUFFER_BIT</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">g_texUnit0</span> <span class="o">&amp;&amp;</span> <span class="nx">g_texUnit1</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLE_STRIP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">n</span><span class="p">);</span>   <span class="c1">// Draw the rectangle
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="6-glsl-es">6 GLSL ES</h1>
<p>WebGL所使用的着色器语言是<strong>GLSL ES 1.0</strong>的子集。</p>
<p>GLSL ES编程语言是在OpenGL着色器语言(GLSL)的基础上，删除和简化一部分功能后形成的，由此带来的好处是降低了硬件功耗和性能开销。</p>
<p>其他部分内容已整理至《GLSL.md》。</p>
<h1 id="7-进入三维世界">7 进入三维世界</h1>
<h2 id="可视空间">可视空间</h2>
<p>有两类常用的可视空间：</p>
<ul>
<li>长方体可视空间，也称盒状空间，由正射投影(orthographic projection)产生。</li>
<li>截锥体/金字塔可视空间，由透视投影(perspective projection)产生。</li>
</ul>
<p>在透视投影下，物体表现为近大远小，产生的三维场景看上去更有深度感，更加自然，因为我们平时观察真实世界用的也是透视投影。在大多数情况下，比如三维射击类游戏中，我们都应当采用透视投影。相比之下，正射投影的好处是用户可以方便地比较场景中物体（比如两个原子的模型）的大小，这是因为物体看上去的大小与距离的远近没有关系。在建筑平面图等技术绘图的相关场合，应当使用这种投影。</p>
<p><code>&lt;canvas＞</code>上显示的就是可视空间中物体<strong>在近裁剪面(即near面)上的投影</strong>。如果近裁剪面的宽高比和<code>&lt;canvas＞</code>不一样，那么画面就会被按照<code>&lt;canvas＞</code>的宽高比进行拉伸和压缩，显示出来的物体就会变形。</p>
<h2 id="正确处理对象的前后关系">正确处理对象的前后关系</h2>
<p>在默认情况下，WebGL为了加速绘图操作，是按照顶点在缓冲区中的顺序来处理顶点数据和绘制图形的，后绘制的图形会遮挡先绘制的图形，而不管他们真实的前后位置关系。</p>
<h3 id="隐藏面消除">隐藏面消除</h3>
<p>为了解决这个问题，WebGL提供了<strong>隐藏面消除</strong>(hidden surface removal)功能，当开启这个功能后，在绘制各个像素前会进行<strong>深度检测</strong>，如果发现这个像素比较“深”(也就是距离观察者较远)且会被近处的物体挡住，那么就不会绘制它。</p>
<p>开启深度检测：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">gl</span><span class="p">.</span><span class="nx">enable</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_TSET</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>绘制每帧图像前都需要清除颜色缓冲和深度缓冲(深度缓冲用来存储深度信息，因为深度一般是指z坐标，所以也称为z缓冲)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">gl</span><span class="p">.</span><span class="nx">clear</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_BUFFER_BIT</span><span class="o">|</span><span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_BUFFER_BIT</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>深度缓冲区中记录了画布上每个位置的最前面的片元的深度（也就是该位置的最小片元深度）。当新绘制一个片元时，会先将它的深度与深度缓冲区中记录的同位置的深度对比，如果新绘制的片元的深度大于缓冲区中的深度，说明该片元会被遮挡，则不绘制；如果新绘制的片元的深度小于缓冲区中的深度，则绘制该片元，并将该片元的深度写入到深度缓冲区中。</p>
</blockquote>
<h3 id="深度冲突了解">深度冲突(了解)</h3>
<p>隐藏面消除是WebGL的一项复杂而又强大的特性，在绝大多数情况下，它都能很好地完成任务。然而，当几何图形或物体的两个表面极为接近时，就会出现新的问题，使得表面看上去斑斑驳驳的，这种现象被称为深度冲突（z fghting）。</p>
<p>之所以会产生深度冲突，是因为两个表面过于接近，深度缓冲区有限的精度已经不能区分哪个在前，哪个在后了。严格地说，如果创建三维模型阶段就对顶点的深度值加以注意，是能够避免深度冲突的。但是，当场景中有多个运动着的物体时，实现这一点几乎是不可能的。</p>
<p>WebGL提供一种被称为多边形偏移（polygon offeet）的机制来解决这个问题。该机制将自动在Z值加上一个偏移量，偏移量的值由物体表面相对于观察者视线的角度来确定。</p>
<p>示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">// 开启多边形偏移
</span><span class="c1"></span>  <span class="nx">gl</span><span class="p">.</span><span class="nx">enable</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">POLYGON_OFFSET_FILL</span><span class="p">);</span>

  <span class="c1">// 先绘制一个三角形
</span><span class="c1"></span>  <span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>   <span class="c1">// The green triangle
</span><span class="c1"></span>  <span class="c1">// 设置多边形偏移参数后再绘制一个三角形
</span><span class="c1"></span>  <span class="nx">gl</span><span class="p">.</span><span class="nx">polygonOffset</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>          <span class="c1">// Set the polygon offset
</span><span class="c1"></span>  <span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLES</span><span class="p">,</span> <span class="nx">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// The yellow triangle
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">function</span> <span class="nx">initVertexBuffers</span><span class="p">(</span><span class="nx">gl</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">verticesColors</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Float32Array</span><span class="p">([</span>
    <span class="c1">// Vertex coordinates and color
</span><span class="c1"></span>    <span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="c1">// The green triangle
</span><span class="c1"></span>    <span class="o">-</span><span class="mf">2.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span>
    <span class="mf">2.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span>

    <span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="c1">// The yellow triagle
</span><span class="c1"></span>    <span class="o">-</span><span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span>
    <span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span>
  <span class="p">]);</span>
  <span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="通过顶点索引绘制物体">通过顶点索引绘制物体</h2>
<p>在调用<code>gl.drawElements()</code>时， WebGL首先从绑定到<code>gl.ELEMENT_ARRAY_BUFFER</code>的缓冲区中获取顶点的索引值，然后根据该索引值，从绑定到<code>gl.ARRAY_BUFFER</code>的缓冲区中获取顶点的坐标、颜色等信息，然后传递给attribute变量并执行顶点着色器。对每个索引值都这样做，最后就绘制出了整个图形，而此时你只调用了一次<code>gl.drawElements()</code>。这种方式通过索引来访问顶点数据，从而实现重复利用顶点信息，控制内存的开销，但代价是你需要通过索引来间接地访问顶点，在某种程度上使程序复杂化了。所以，<code>gl.drawElements()</code>和<code>gl.drawArrays()</code>各有优劣，具体用哪一个取决于具体的需求。</p>
<h1 id="8-光照">8 光照</h1>
<h2 id="光源类型">光源类型</h2>
<ul>
<li><strong>平行光(方向光)</strong>：顾名思义，平行光的光线是相互平行的，平行光具有方向。平行光可以看作是无限远处的光源（比如太阳）发出的光。因为太阳距离地球很远，所以阳光到达地球时可以认为是平行的。平行光很简单，可以用一个方向和一个颜色来定义（光的颜色中已经包含了光强度信息，比如(2,2,2)是比(1,1,1)更强的白光）。</li>
<li><strong>点光源光</strong>：点光源光是从一个点向周围的所有方向发出的光。点光源光可以用来表示现实中的灯泡、火焰等。我们需要指定点光源的位置和颜色。光线的方向将根据点光源的位置和被照射之处的位置计算出来，因为点光源的光线方向在场景内的不同位置是不同的。</li>
<li><strong>环境光</strong>：环境光（间接光）是指那些经光源（点光源或平行光源）发出后，被墙壁等物体多次反射，然后照到物体表面上的光。环境光从各个角度照射物体，其强度都是一致的。比如说，在夜间打开冰箱的门，整个厨房都会有些微微亮，这就是环境光的作用。环境光不用指定位置和方向，只需要指定颜色即可。</li>
</ul>
<h2 id="反射类型">反射类型</h2>
<p>我们能看见物体是因为物体的反射光进入了我们的眼睛。</p>
<ul>
<li>漫反射：针对平行光和点光源。详见书。</li>
<li>环境反射：针对环境光。详见书。</li>
</ul>
<h2 id="平行光下的漫反射计算原理">平行光下的漫反射计算原理</h2>
<p>详见书page286开始。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">// θ为入射角
// 在glsl中，两个矢量的相乘(*)的结果是仍是一个矢量
漫反射光颜色 = 物体表面基色*入射光颜色*cosθ

// 两个矢量的点乘积是一个标量
漫反射光颜色 = 物体表面基色*入射光颜色*(物体表面法线方向·光线方向)
</code></pre></td></tr></table>
</div>
</div><p><img src="5.PNG" alt=""></p>
<p>注意，这里所谓的“光线方向”，实际上是入射方向的反方向，即从入射点指向光源，只有这样，该方向与法线方向之间的夹角才是入射角。</p>
<h2 id="环境反射计算原理">环境反射计算原理</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">环境反射光颜色 = 物体表面基色*入射光颜色
</code></pre></td></tr></table>
</div>
</div><p>进一步地：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">漫反射光颜色+环境反射光颜色 = 物体表面基色*( 漫反射入射光颜色*(物体表面法线方向·光线方向) + 环境光颜色 )
</code></pre></td></tr></table>
</div>
</div><h2 id="魔法矩阵逆转置矩阵">魔法矩阵：逆转置矩阵</h2>
<p>需要注意的是，立方体旋转时，每个顶点的法向量也会随之变化。</p>
<p><strong>以顶点法向量乘以模型矩阵的逆转置矩阵，就可以求得顶点在经过模型矩阵变换后的新的法向量</strong>。</p>
<blockquote>
<p>准确地说，应该用modelviewMatrix的逆转置矩阵。</p>
<p>因为viewMatrix本质上和modelMatrix一样，都是对物体进行旋转、平移、缩放等操作，所以这里笼统地把modelviewMatrix称为modelMatrix。</p>
</blockquote>
<h2 id="点光源下的漫反射计算原理">点光源下的漫反射计算原理</h2>
<p>平行光的入射方向始终不变，而点光源的入射方向随被照射点位置的不同而不同。</p>
<p>前面我们根据每个顶点的法向量和平行光人射方向来计算反射光的颜色。这一节还是采用该方法，只不过点光源光的方向不再是恒定不变的，而要根据每个顶点的位置逐一计算。着色器需要知道点光源的所在位置，而不是光的方向。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">attribute</span> <span class="k">vec4</span> <span class="n">a_Position</span><span class="p">;</span>    <span class="c1">// 顶点位置</span>
<span class="k">attribute</span> <span class="k">vec4</span> <span class="n">a_Color</span><span class="p">;</span>       <span class="c1">// 顶点颜色</span>
<span class="k">attribute</span> <span class="k">vec4</span> <span class="n">a_Normal</span><span class="p">;</span>      <span class="c1">// 顶点法向量</span>
<span class="k">uniform</span> <span class="n">mat4</span> <span class="n">u_MvpMatrix</span><span class="p">;</span>     <span class="c1">// model view projection复合矩阵</span>
<span class="k">uniform</span> <span class="n">mat4</span> <span class="n">u_ModelMatrix</span><span class="p">;</span>   <span class="c1">// model矩阵</span>
<span class="k">uniform</span> <span class="n">mat4</span> <span class="n">u_NormalMatrix</span><span class="p">;</span>  <span class="c1">// model矩阵的逆转置矩阵，用来变换顶点法向量</span>
<span class="k">uniform</span> <span class="k">vec3</span> <span class="n">u_LightColor</span><span class="p">;</span>    <span class="c1">// 点光源颜色</span>
<span class="k">uniform</span> <span class="k">vec3</span> <span class="n">u_LightPosition</span><span class="p">;</span> <span class="c1">// 点光源位置 (世界坐标系)</span>
<span class="k">uniform</span> <span class="k">vec3</span> <span class="n">u_AmbientLight</span><span class="p">;</span>  <span class="c1">// 环境光颜色</span>
<span class="k">varying</span> <span class="k">vec4</span> <span class="n">v_Color</span><span class="p">;</span>
<span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">u_MvpMatrix</span> <span class="o">*</span> <span class="n">a_Position</span><span class="p">;</span>
  <span class="c1">// 计算经过模型矩阵变换后的顶点的法向量</span>
  <span class="k">vec3</span> <span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="k">vec3</span><span class="p">(</span><span class="n">u_NormalMatrix</span> <span class="o">*</span> <span class="n">a_Normal</span><span class="p">));</span>
  <span class="c1">// 计算经过模型矩阵变换后的顶点的坐标（即世界坐标）</span>
  <span class="k">vec4</span> <span class="n">vertexPosition</span> <span class="o">=</span> <span class="n">u_ModelMatrix</span> <span class="o">*</span> <span class="n">a_Position</span><span class="p">;</span>
  <span class="c1">// 计算光照方向</span>
  <span class="k">vec3</span> <span class="n">lightDirection</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">u_LightPosition</span> <span class="o">-</span> <span class="k">vec3</span><span class="p">(</span><span class="n">vertexPosition</span><span class="p">));</span>
  <span class="c1">// cosθ</span>
  <span class="k">float</span> <span class="n">nDotL</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">lightDirection</span><span class="p">,</span> <span class="n">normal</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
  <span class="c1">// 漫反射光</span>
  <span class="k">vec3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">u_LightColor</span> <span class="o">*</span> <span class="n">a_Color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">nDotL</span><span class="p">;</span>
  <span class="c1">// 环境光</span>
  <span class="k">vec3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="n">u_AmbientLight</span> <span class="o">*</span> <span class="n">a_Color</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
  <span class="c1">// 总的光照效果</span>
  <span class="n">v_Color</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">diffuse</span> <span class="o">+</span> <span class="n">ambient</span><span class="p">,</span> <span class="n">a_Color</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="更逼真的效果逐片元光照了解">更逼真的效果：逐片元光照(了解)</h2>
<p>WebGL系统会根据顶点的颜色，内插出表面上每个片元的颜色。实际上，点光源光照射到一个表面上所产生的效果（即每个片元获得的颜色）与简单使用4个顶点颜色（虽然这4个顶点的颜色也是由点光源产生）内插出的效果并不完全相同（在某些极端情况下甚至很不一样），所以为了使效果更加逼真，我们需要对表面的每一点（而不仅仅是4个顶点）计算光照效果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="c1">// 顶点着色器</span>

<span class="k">attribute</span> <span class="k">vec4</span> <span class="n">a_Position</span><span class="p">;</span>     <span class="c1">// 顶点坐标</span>
<span class="k">attribute</span> <span class="k">vec4</span> <span class="n">a_Normal</span><span class="p">;</span>       <span class="c1">// 顶点法向量</span>
<span class="k">uniform</span> <span class="n">mat4</span> <span class="n">u_MvpMatrix</span><span class="p">;</span>      <span class="c1">// model view projection复合矩阵</span>
<span class="k">uniform</span> <span class="n">mat4</span> <span class="n">u_ModelMatrix</span><span class="p">;</span>    <span class="c1">// model矩阵</span>
<span class="k">uniform</span> <span class="n">mat4</span> <span class="n">u_NormalMatrix</span><span class="p">;</span>   <span class="c1">// model矩阵的逆转置矩阵，用来变换顶点法向量</span>
<span class="k">varying</span> <span class="k">vec4</span> <span class="n">v_Color</span><span class="p">;</span>          <span class="c1">// 传递给片元着色器的片元颜色</span>
<span class="k">varying</span> <span class="k">vec3</span> <span class="n">v_Normal</span><span class="p">;</span>         <span class="c1">// 传递给片元着色器的片元的法向量</span>
<span class="k">varying</span> <span class="k">vec3</span> <span class="n">v_Position</span><span class="p">;</span>       <span class="c1">// 传递给片元着色器的片元的坐标</span>
<span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">vec4</span> <span class="n">color</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">u_MvpMatrix</span> <span class="o">*</span> <span class="n">a_Position</span><span class="p">;</span>

  <span class="c1">// 计算经过模型矩阵变换后的顶点的坐标（即世界坐标）</span>
  <span class="n">v_Position</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="n">u_ModelMatrix</span> <span class="o">*</span> <span class="n">a_Position</span><span class="p">);</span>
  <span class="c1">// 计算经过模型矩阵变换后的顶点的法向量</span>
  <span class="n">v_Normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="k">vec3</span><span class="p">(</span><span class="n">u_NormalMatrix</span> <span class="o">*</span> <span class="n">a_Normal</span><span class="p">));</span>
  <span class="n">v_Color</span> <span class="o">=</span> <span class="n">color</span><span class="p">;</span> 
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="c1">// 片元着色器</span>

<span class="cp">#ifdef GL_ES</span>
<span class="k">precision</span> <span class="k">mediump</span> <span class="k">float</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="k">uniform</span> <span class="k">vec3</span> <span class="n">u_LightColor</span><span class="p">;</span>     <span class="c1">// 点光源颜色</span>
<span class="k">uniform</span> <span class="k">vec3</span> <span class="n">u_LightPosition</span><span class="p">;</span>  <span class="c1">// 点光源位置 (世界坐标系)</span>
<span class="k">uniform</span> <span class="k">vec3</span> <span class="n">u_AmbientLight</span><span class="p">;</span>   <span class="c1">// 环境光颜色</span>
<span class="k">varying</span> <span class="k">vec3</span> <span class="n">v_Normal</span><span class="p">;</span>         <span class="c1">// 片元的法向量</span>
<span class="k">varying</span> <span class="k">vec3</span> <span class="n">v_Position</span><span class="p">;</span>       <span class="c1">// 片元的坐标</span>
<span class="k">varying</span> <span class="k">vec4</span> <span class="n">v_Color</span><span class="p">;</span>           <span class="c1">// 片元的颜色</span>
<span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 对片元的法向量进行归一化(单位化)，因为顶点的法向量经过内插之后有可能不再是单位向量</span>
  <span class="k">vec3</span> <span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">v_Normal</span><span class="p">);</span>
  <span class="c1">// 计算光照方向</span>
  <span class="k">vec3</span> <span class="n">lightDirection</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">u_LightPosition</span> <span class="o">-</span> <span class="n">v_Position</span><span class="p">);</span>
  <span class="c1">// cosθ</span>
  <span class="k">float</span> <span class="n">nDotL</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">lightDirection</span><span class="p">,</span> <span class="n">normal</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
  <span class="c1">// 漫反射光</span>
  <span class="k">vec3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">u_LightColor</span> <span class="o">*</span> <span class="n">v_Color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">nDotL</span><span class="p">;</span>
  <span class="c1">// 环境光</span>
  <span class="k">vec3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="n">u_AmbientLight</span> <span class="o">*</span> <span class="n">v_Color</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
  <span class="c1">// 总的光照效果</span>
  <span class="n">gl_FragColor</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">diffuse</span> <span class="o">+</span> <span class="n">ambient</span><span class="p">,</span> <span class="n">v_Color</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>顶点着色器使用模型矩阵乘以顶点坐标计算出顶点的世界坐标，将其赋值给v_Position变量，经过内插过程后，片元着色器就获得了逐片元的v_Position变量，也就是片元的世界坐标。类似地，顶点着色器将顶点的法向量赋值给v_Normal变量，经过内插，片元着色器就获得了逐片元的v_Normal变量，即片元的法向量。</p>
<h1 id="9-层次模型">9 层次模型</h1>
<h2 id="层次结构模型">层次结构模型</h2>
<p><img src="7.PNG" alt=""></p>
<p>绘制机器人手臂这样一个复杂的模型，最常用的方法就是按照模型中各个部件的层次顺序，从高到低逐一绘制，并在每个关节上应用模型矩阵。</p>
<p>注意，三维模型和现实中的人类或机器人不一样，它的部件并没有真正连接在一起。如果直接转动上臂，那么肘部以下的部分，包括前臂、手掌和手指，只会留在原地，这样手臂就断开了。所以，当上臂绕肩关节转动时，你需要在代码中实现“肘部以下部分跟随上臂转动”的逻辑。具体地，上臂绕肩关节转动了多少度，肘部以下的部分也应该绕肩关节转动多少度。</p>
<p>当情况较为简单时，实现“部件A转动带动部件B转动”可以很直接，只要对部件B也施以部件A的旋转矩阵即可。比如，使用模型矩阵使上臂绕肩关节转动30度，然后在绘制肘关节以下的各部位时，为它们施加同一个模型矩阵，也令其绕肩关节转动30度，这样，肘关节以下的部分就能自动跟随上臂转动了。</p>
<p>如果情况更复杂一些，比如先使上臂绕肩关节转动30度，然后使前臂绕肘关节转动10度，那么对肘关节以下的部分，你就得先施加上臂绕肩关节转动30度的矩阵（可称为“肩关节模型矩阵” ) ，然后再施加前臂绕肘关节转动10度的矩阵。将这两个矩阵相乘，其结果可称为“肘关节模型矩阵”，那么在绘制肘关节以下部分的时候，直接应用这个所谓的“肘关节模型矩阵”。</p>
<p>按照上述方式编程，三维场景中的肩关节就能影响肘关节，使得上臂的运动带动前臂的运动；反过来，不管前臂如何运动都不会影响上臂。这就与现实中的情况相符合了。</p>
<h2 id="单关节模型">单关节模型</h2>
<blockquote>
<p>下图中，arm1是上臂，arm2是前臂。</p>
</blockquote>
<p><img src="8.PNG" alt=""></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="p">...</span>
<span class="c1">// 先绘制Arm1
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">arm1Length</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span> <span class="c1">// Length of arm1
</span><span class="c1">// 注意：带有set的函数，不会保留矩阵原有的变换；不带有set的函数，会保留矩阵原有的变换
</span><span class="c1"></span><span class="nx">g_modelMatrix</span><span class="p">.</span><span class="nx">setTranslate</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">12.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
<span class="nx">g_modelMatrix</span><span class="p">.</span><span class="nx">rotate</span><span class="p">(</span><span class="nx">g_arm1Angle</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span> <span class="c1">// Rotate around the y-axis
</span><span class="c1"></span><span class="nx">drawBox</span><span class="p">(</span><span class="nx">gl</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">viewProjMatrix</span><span class="p">,</span> <span class="nx">u_MvpMatrix</span><span class="p">,</span> <span class="nx">u_NormalMatrix</span><span class="p">);</span> <span class="c1">// Draw
</span><span class="c1"></span>
<span class="c1">// 再绘制Arm2
</span><span class="c1"></span><span class="nx">g_modelMatrix</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nx">arm1Length</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span> <span class="c1">// Move to joint1
</span><span class="c1"></span><span class="nx">g_modelMatrix</span><span class="p">.</span><span class="nx">rotate</span><span class="p">(</span><span class="nx">g_joint1Angle</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span> <span class="c1">// Rotate around the z-axis
</span><span class="c1"></span><span class="nx">drawBox</span><span class="p">(</span><span class="nx">gl</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">viewProjMatrix</span><span class="p">,</span> <span class="nx">u_MvpMatrix</span><span class="p">,</span> <span class="nx">u_NormalMatrix</span><span class="p">);</span> <span class="c1">// Draw
</span><span class="c1"></span><span class="p">...</span>
</code></pre></td></tr></table>
</div>
</div><p>绘制arm1和arm2使用了同一个模型矩阵g_modelMatrix，这样上面对arm1所做的旋转操作也会被应用到arm2上。</p>
<h1 id="10-高级技术">10 高级技术</h1>
<h2 id="选中物体">选中物体</h2>
<p>技巧：</p>
<ol>
<li>当鼠标左键按下时，将整个立方体重绘为单一的红色。</li>
<li>读取鼠标点击处的颜色。</li>
<li>使用立方体原来的颜色对其进行重绘。</li>
<li>如果第2步读取到的颜色是红色，说明选中了物体。</li>
</ol>
<p>对于具有多个物体的场景，这个简单的方法也能适用，只需要为场景中的每个物体都指定不同的颜色即可。</p>
<h2 id="hud">HUD</h2>
<p>Head Up Display，抬头显示。它的作用，就是把时速、导航等重要的行车信息，投射到驾驶员前面的挡风玻璃上，让驾驶员尽量做到不低头、不转头就能看到时速、导航等重要的驾驶信息。</p>
<p>三维图形程序，尤其是游戏，也经常在三维场景上叠加文本或二维图形信息，以达到HUD的效果。</p>
<p>如何实现HUD？创建两个canvas重叠放置，在下层的canvas上使用WebGL绘制3D图形，在上层的canvas上使用canvas 2D API绘制HUD信息。</p>
<h2 id="绘制圆形的点">绘制圆形的点</h2>
<p>见《GLSL.md》。</p>
<h2 id="α混合">α混合</h2>
<h3 id="如何实现α混合">如何实现α混合</h3>
<p>详见书。</p>
<h3 id="混合函数">混合函数</h3>
<p>详见书。</p>
<h3 id="半透明的三维物体">半透明的三维物体</h3>
<p>详见书。</p>
<h3 id="透明与不透明物体共存">透明与不透明物体共存</h3>
<p>详见书。</p>
<h2 id="切换着色器">切换着色器</h2>
<p>通过<code>gl.useProgram(...)</code>来切换使用的着色器程序，也就切换了其相关联的顶点着色器和片段着色器。</p>
<h2 id="使用渲染结果作为纹理使用帧缓冲区对象">使用渲染结果作为纹理——使用帧缓冲区对象</h2>
<p>另一项简单而又强大的技术是，使用WebGL渲染三维图形，然后将渲染结果作为纹理贴到另一个三维物体上去。</p>
<p>在默认情况下，WebGL在<strong>颜色缓冲区</strong>中进行绘图，在开启隐藏面消除功能时，还会用到<strong>深度缓冲区</strong>。总之，绘制的结果图像是存储在颜色缓冲区中的。</p>
<p><strong>帧缓冲区对象(framebuffer object)</strong> 可以用来代替颜色缓冲区和深度缓冲区。绘制在帧缓冲区中的对象并不会直接显示在<code>&lt;canvas&gt;</code>上，你可以先对帧缓冲区中的内容进行一些处理再显示，或者直接用其中的内容作为纹理图像。</p>
<p>在帧缓冲区中进行绘制的过程又称为<strong>离屏绘制(offscreen drawing)</strong>。</p>
<p>详见书。</p>
<h2 id="绘制阴影">绘制阴影</h2>
<p>详见书。</p>
<h2 id="加载obj格式的三维模型">加载OBJ格式的三维模型</h2>
<p>详见书。</p>
<h2 id="处理上下文丢失">处理上下文丢失</h2>
<p>WebGL使用了计算机的图形硬件，而这部分资源是被操作系统管理，由包括浏览器在内的多个应用程序共享。在某些特殊情况下，如另一个程序接管了图形硬件，或者操作系统进入休眠，浏览器就会失去使用这些资源的权利，并导致存储在图形硬件中的数据丢失。在这种情况下，WebGL绘图上下文就会丢失。</p>
<p>我们可以监听WebGL提供的<code>webglcontextlost</code>和<code>webglcontextrestored</code>事件来处理这种情况。</p>
<p>详见书。</p>
<h1 id="11-附录">11 附录</h1>
<h2 id="左手坐标系or右手坐标系">左手坐标系or右手坐标系</h2>
<p><strong>OpenGL裁剪坐标系、NDC</strong>是<strong>左手坐标系</strong>；<strong>数学、物理学、3D建模、OpenGL视觉坐标系</strong>(eye coordinates)等，是<strong>右手坐标系</strong>。</p>
<p>顶点着色器中的<strong>gl_position</strong>是顶点的<strong>裁剪坐标</strong>，因而使用的是<strong>左手坐标系</strong>。</p>
<p>通过<strong>投影矩阵</strong>的处理，顶点的视觉坐标变成了裁剪坐标，右手坐标系中的点被变换到左手坐标系中。</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/webgl/">WebGL</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/20220126three/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">three.js源码阅读</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/20220122webgl2/">
            <span class="next-text nav-default">WebGL入门</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:al4fun@163.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/al4fun" class="iconfont icon-github" title="github"></a>
  <a href="https://al4fun.gitee.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2016 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>al4fun</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>








</body>
</html>
